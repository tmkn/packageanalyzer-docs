---
slug: devblog2
title: "Devblog #2 - Splitting up the codebase"
author: Thomas Klein
#author_title: Front End Engineer @ Facebook
author_url: https://twitter.com/tmkndev
author_image_url: https://avatars.githubusercontent.com/u/2671613?v=4&s=400
tags: [packageanalyzer, devblog]
description: In this edition I talk about the reason why I split up the codebase
keywords: [packageanalyzer, devblog, typescript]
draft: true
---

## Introduction
I'm a huge fan of `TypeScript`. I don't know when I first stumbled upon it but I think it must have been around 2015. I just looked at it and I was already convinced. Only then I found out that the project is also led by [Anders Hejlsberg](https://en.wikipedia.org/wiki/Anders_Hejlsberg) which solidified my quick judgement only further :sweat_smile:

Anders co-designd several programming languages, among them `C#` which I highly like since it offers a great developer experience and it's just a pleasure to work with. So it was a no brainer to also follow this project.

I like `TypeScript` because it's not trying to replace `JavaScript` like so many other compile to `JavaScript` languages. Its purpose is to retrofit `JavaScript` with a type system. No need to learn completely new syntax like `CoffeScript` (which I never did for precisely this reason). As a `JavaScript` developer you can hit the ground running right away.

Unfortunately since it's not trying to replace `JavaScript` but rather work within its constraints the type system is not as strict as I sometimes would like it to be.

So whenever there's a new `TypeScript` release with a new setting that would improve the type safety further, I'll try it out.

So I did with the `noUncheckedIndexedAccess` setting which was added in 4.1.

## Status Quo
While the project is already making use of the `strict` compile setting, `noUncheckedIndexedAccess` needs to be added manually as it's not part of the `strict` rule family.

### `noUncheckedIndexedAccess`
In short this setting makes accessing items in an array stricter.
Even with the `strict` setting, the following code will not error even though it should!.
```typescript
let names: string[] = [];   //empty array
let first = names[0];

first.toUpperCase();    //no error!
```
In this case, `first` is actually `undefined` so calling `first.toUpperCase()` will result in a runtime exception, not good.

By turning on `noUncheckedIndexedAccess` this particular code will now error as expected:
```typescript
let names: string[] = [];
let first = names[0];

first.toUpperCase();    //Object is possibly 'undefined'.
```
So to access this variable properly it now needs a dedicated check:
```typescript
let names: string[] = [];
let first = names[0];

if(first)
    first.toUpperCase();    //all good now
```
Since this setting can be rather noisy it's not included in the default settings for `strict`;

### Current code
So lets turn it on for our code:

![compile errors](./devblog2/errors.jpg "Compile Errors")

54 errors, quite some.

But if we look closely most of them are coming from the unit tests.
## Project References
blabla
## Final Setup