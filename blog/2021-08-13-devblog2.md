---
slug: devblog2
title: "Devblog #2 - Splitting up the codebase"
author: Thomas Klein
#author_title: Front End Engineer @ Facebook
author_url: https://twitter.com/tmkndev
author_image_url: https://avatars.githubusercontent.com/u/2671613?v=4&s=400
tags: [packageanalyzer, devblog]
description: In this edition I talk about the reason why I split up the codebase
keywords: [packageanalyzer, devblog, typescript]
draft: true
---

## Introduction
I'm a huge fan of `TypeScript`. I don't know when I first stumbled upon it but I think it must have been around 2015. I just looked at it and I was already convinced. Only then I found out that the project is also led by [Anders Hejlsberg](https://en.wikipedia.org/wiki/Anders_Hejlsberg) which solidified my quick judgement only further :sweat_smile:

Anders co-designd several programming languages, among them `C#` which I highly like since it offers a great developer experience and it's just a pleasure to work with. So it was a no brainer to also follow this project.

I like `TypeScript` because it's not trying to replace `JavaScript` like so many other compile to `JavaScript` languages. Its purpose is to retrofit `JavaScript` with a type system. No need to learn completely new syntax like `CoffeScript` (which I never did for precisely this reason). As a `JavaScript` developer you can hit the ground running right away.

Unfortunately since it's not trying to replace `JavaScript` but rather work within its constraints the type system is not as strict as I sometimes would like it to be.

So whenever there's a new `TypeScript` release with a new setting that would improve the type safety further, I'll try it out.

So I did with the `noUncheckedIndexedAccess` setting which was added in 4.1.

## Status Quo
While the project is already making use of the `strict` compile setting, `noUncheckedIndexedAccess` needs to be added manually as it's not part of the `strict` rule family.

### `noUncheckedIndexedAccess`
In short this setting makes accessing items in an array stricter.
Even with the `strict` setting, the following code will not error even though it should!.
```typescript
let names: string[] = [];   //empty array
let first = names[0];

first.toUpperCase();    //no error!
```
In this case, `first` is actually `undefined` so calling `first.toUpperCase()` will result in a runtime exception, not good.

By turning on `noUncheckedIndexedAccess` this particular code will now error as expected:
```typescript
let names: string[] = [];
let first = names[0];

first.toUpperCase();    //Object is possibly 'undefined'.
```
So to access this variable properly it now needs a dedicated check:
```typescript
let names: string[] = [];
let first = names[0];

if(first)
    first.toUpperCase();    //all good now
```
Since this setting can be rather noisy it's not included in the default settings for `strict`;

### First test run
So lets turn it on for our code:

![compile errors](./devblog2/errors.jpg "Compile Errors")

54 errors, quite some.

But if we look closely most of them are actually coming from the unit tests like:
```bash
tests/nameVisitor.test.ts:158:16 - error TS2532: Object is possibly 'undefined'.

158         expect(rest[0].license).toBe("ISC");
                   ~~~~~~~
```
While in this case I could satifisy the compiler quite nicely with optional chaining:
```typescript
expect(rest[0].license)!.toBe("ISC");
```
More work would be required if destructuring is used:
```bash
tests/nameVisitor.test.ts:153:18 - error TS2339: Property 'license' does not exist on type '{ license: string; names: string[]; } | undefined'.

153         const [{ license, names }, ...rest] = new LicenseUtilities(p).licensesByGroup;
                     ~~~~~~~
```

Since I didn't feel like this setting is particularily useful for unit tests where you have defined inputs and you're looking for the expected output, I thought maybe there's a way I can apply `noUncheckedIndexedAccess` only to the actual source code. Turns out there's a way!

### Current setup
The project setup is fairly simple, there is a single `tsconfig.json` which includes the `src` and `tests` folders.

While it wasn't a problem for this project, this actually has some drawbacks. As you could import stuff from `src` into `tests` you could also import stuff from `tests` into `src`, which you probably don't ever want to do. Also if you just changed the _internals_ of your source it required typechecking of everything under `tests`, even though this wouldn't ever cause new errors in the unit tests.

But more importantly it also means that the compile settings are shared between `src` and `tests`. So with this setup, enabling `noUncheckedIndexedAccess` would enable it for both folders. There's no way to selectively enable it only for the `src` folder.

One way would be to create 2 `TypeScript` projects one in the `src` folder and one in `tests` but that also means to start the `TypeScript` compiler 2x :grimacing:

Luckily `TypeScript` already provides a solution to that problem, namely [Project References](https://www.typescriptlang.org/docs/handbook/project-references.html).

## Project References
With project references I can selective enable different compile settings for different folders (projects).

This allows me to setup `src` in a way that I cannot accidentally import anything from `tests`, while `tests` itself can import stuff from `src`.

If the unit tests are compiled, it will look where the import is from and apply different compile settings, anything that is imported from the `src` folder will be compiled with `noUncheckedIndexedAccess` while everything under `tests` will be compiled like always.

Best of it is that I don't need 2 separate `TypeScript` processes for it, I still only need to start the `TypeScript` compiler once.

I just have to tell `TypeScript` that I'm using project references:
```bash
#old
tsc --watch

#new
tsc --watch --build
```
## Final Setup