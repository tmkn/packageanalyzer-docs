---
slug: devblog8
title: "Devblog #8 - Improved DX"
authors: tmkn
tags: [devblog]
description: "Improved the developer experience by enabling easier report parameter validation as well as easier data extraction from the dependency tree"
keywords: [packageanalyzer, devblog]
---

## Introduction

Work was done on improving the developer experience. Some of it was planned, like the report parameter validation and some of it came naturally, like improved data extraction from the dependency tree.

<!--truncate-->

:::info
This devblog is about the `packageanalyzer` project.

_A framework to introspect Node.js packages._

Please find a short introduction and the motivation for this project [here](/docs/intro).
:::

## A built in way to collect custom data

There is now an easy way to traverse the dependency tree and collect custom data.

### Problem

While working on a new `install script detector` feature to identify `preinstall` and `postinstall` scripts I realized there is no built in way to traverse the dependency tree and collect custom data.

There is the `visit` method on the `Package` class but this will only allow a callback to be executed for every dependency. Any data that you want to collect during this traversal needs to be saved manually.

So if we want to collect all `postinstall` entries, the code might have looked liked this:

```typescript
const postinstallMap: Map<string, string> = new Map();

// iterate through the dependency tree
root.visit((pkg) => {
  const postinstallEntry = pkg.getData("scripts.postinstall");

  if (postinstallEntry) postinstallMap.set(pkg.fullName, postinstallEntry);
}, true /* start from root */);
```

While this doesn't look too bad, it's possible that the same dependency (same version) exists multiple times in the dependency tree. If we want to collect all instances (because we want to display a path to show where the dependency lies in the dependency tree) the above code wouldn't work.

We need to track the individual `Package`, so we use `Package` as the key:

```typescript
const postinstallMap: Map<Package, string> = new Map();

root.visit((pkg) => {
  const postinstallEntry = pkg.getData("scripts.postinstall");

  if (postinstallEntry) postinstallMap.set(pkg, postinstallEntry);
}, true);
```

Now we get all possible instances where there is a `postinstall` script. But since how the data is saved is totally up to the developer, another approach would be to use a tuple:

```typescript
const postinstallTuples: [Package, string][] = [];

root.visit((pkg) => {
  const postinstallEntry = pkg.getData("scripts.postinstall");

  if (postinstallEntry) postinstallTuples.push([pkg, postinstallEntry]);
}, true);
```

That would work as well but what if we want to group same dependencies together? Whoops, yet another implementation is needed.

So we might then do something like this:

```typescript
interface IPostInstall {
  pkgs: Package[]; //track dependencies
  postinstall: string;
}

const postinstallMap: Map<string, IPostInstall> = new Map();

root.visit((pkg) => {
  const postinstallEntry = pkg.getData("scripts.postinstall");

  if (postinstallEntry)
    // read current entry or create new one if it doesn't exist
    const value = postinstallMap.get(pkg.fullName) ?? {
      pkgs: [],
      postinstall: postinstallEntry,
    };

  // add current package
  value.pkgs.push(pkg);

  // save
  postinstallMap.set(pkg.fullName, value);
}, true);
```

The burden is on the _developer_ as there is no built in way to collect data like this and as just shown there are multiple ways to do it.

Traversing and collecting data from the dependecy tree is such a common theme that there really ought to be an _official_ way to do it.

### Solution

The `Package` class now contains a `collect` method that lets you iterate through the dependency tree and collect custom data along the way.

It is itself nested in structure, containing accessors to the `parent` as well as the `children` (dependencies).

Additionally it contains a `flatten` method to turn the nested structure into an easy to consume data structure, giving you the option to group same dependencies (dependencies with same version).

The `collect` method takes a callback where the return value of that callback is the data that is getting collected.

The implementation of the `postinstall` example can now look like this:

```typescript
// collect postinstall entries and group same dependencies
const postinstallMap = root
  .collect((pkg) => pkg.getData("scripts.postinstall"))
  .flatten(true);
```

**Much** more straight forward ðŸ™Œ.

If we want to print out the information we can do it with a simple `for of` loop:

```typescript
// print out
for (const [[pkg, ...rest], postinstall] of postinstallMap) {
  if (postinstall)
    console.log(
      `Found postinstall entry for ${pkg.fullName}: "${postinstall}"`
    );
  console.log(
    `${pkg.fullName} exists ${rest.length + 1}x in the dependency tree`
  );
}
```

If we don't want to group same dependencies we can provide `false` or no argument to `flatten`:

```typescript
// collect postinstall entries and group same dependencies
const postinstallMap = root
  .collect((pkg) => pkg.getData("scripts.postinstall"))
  .flatten();

// print out
for (const [pkg, postinstall] of postinstallMap) {
  if (postinstall)
    console.log(
      `Found postinstall entry for ${pkg.fullName}: "${postinstall}"`
    );
}
```

If we want to also add `preinstall` entries we can simply add it to the `collect` return value:

*Here utilizing an interface to describe the return value, so the implementation returns the correct data*

```typescript
interface IScripts {
  preinstall?: string;
  postinstall?: string;
}

const scriptMap = root
  .collect<IScripts>((pkg) => ({
    preinstall: pkg.getData("scripts.preinstall"),
    postinstall: pkg.getData("scripts.postinstall"),
  }))
  .flatten(true);
```

ðŸ™Œ

Now collecting custom data is super easy as you only need to worry about **what** data you want to collect and not **how** you collect it.

## Improved parameter validation

todo
